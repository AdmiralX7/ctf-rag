
### Question: In the 'Broken Trust' exploit, which virtual function table pointer was hijacked, and what specific `SMC` (Secure Monitor Call) handler was invoked to gain privileged execution?
---
<br>

**RAG-Augmented Answer:**

Based on the provided context, here is a concise answer:

*   **Hijacked Pointer:** The exploit did not hijack a virtual function table pointer. Instead, to gain code execution on the host, it overwrote an entry in the **Global Offset Table (GOT)**, specifically the pointer for `write@got.plt`.

*   **Privileged Invocation:** The system does not use SMCs. Privileged execution was gained by calling the **`trustzone_invoke` syscall**, which sets the `trustzone_mode` flag to `true`, allowing the execution of protected syscalls.

**Sources Retrieved by RAG:**
*   Document ID: `40333`
\n**For more details, you can read the full write-ups:**\n*   [Write-up for CTFtime ID 40333](http://ctftime.org/writeup/40333)\n
<br>

---
**Standard LLM Answer (No RAG):**

Of course. The "Broken Trust" exploit, presented by Gal Beniamini at Black Hat USA 2016, was a landmark attack that demonstrated a full compromise of Qualcomm's Secure Execution Environment (QSEE) on Android devices.

The exploit was a two-stage process. Here are the specifics for each part of your question:

### 1. The Hijacked Virtual Function Table (vtable) Pointer

The initial stage of the exploit targeted a user-space application running in the Secure World, known as a **Trustlet** or **Trusted Application (TA)**.

*   **Hijacked Pointer:** The **vtable pointer of a C++ object instance** inside the **`keymaster` Trustlet**.
*   **Vulnerability:** The attackers discovered a heap-based buffer overflow vulnerability within the `keymaster` Trustlet. This Trustlet is responsible for handling cryptographic keys and is a standard component in Android's hardware-backed keystore system.
*   **Mechanism:**
    1.  An application in the Normal World (Android) would send a specially crafted, malformed key blob to the `keymaster` Trustlet for processing.
    2.  When parsing this data, the `keymaster` Trustlet would trigger the buffer overflow, allowing the attacker to overwrite data on the heap.
    3.  The overflow was carefully controlled to overwrite a C++ object that was allocated adjacent to the buffer. Specifically, they overwrote its **vtable pointer**.
    4.  The attacker replaced the legitimate vtable pointer with a pointer to a fake vtable they had placed in memory (as part of their malicious key blob data).
    5.  When the program later tried to call a virtual function on this corrupted object (e.g., during cleanup), it would read the hijacked vtable pointer, look up the function address in the attacker-controlled fake vtable, and jump to the attacker's shellcode.

This gave the attacker code execution, but only within the context of the `keymaster` Trustlet, which is a sandboxed, user-level process inside the Secure World.

### 2. The Invoked SMC Handler for Privilege Escalation

To escape the Trustlet's sandbox and gain full control over the Secure World, the attackers needed to compromise the TEE's kernel (the QSEE kernel). They did this by exploiting a vulnerability in a specific Secure Monitor Call (SMC) handler.

*   **SMC Handler:** The specific handler invoked was for a **logging service**. In the researchers' target, this corresponded to **`SMC #0x12`**.
*   **Vulnerability:** The logging SMC handler was designed to take a *physical memory address* and size from the Trustlet, map that region into the TEE kernel's address space, and use it as a log buffer. The critical flaw was a **lack of validation**. The handler did not check if the provided physical address pointed to a legitimate, non-secure memory region.
*   **Mechanism:**
    1.  The shellcode, now running inside the `keymaster` Trustlet, would invoke `SMC #0x12`.
    2.  As the argument, it passed the **physical address of the TEE kernel's own page tables**.
    3.  The vulnerable SMC handler in the TEE kernel received this request and, trusting its caller, mapped its own page tables into a virtual address space that was writable by the `keymaster` Trustlet.
    4.  With write access to the TEE kernel's page tables, the shellcode simply modified the page table entries to mark the kernel's code and data segments as writable.
    5.  Once the TEE kernel memory was writable, the attacker had full control. They could patch the kernel, disable security mechanisms like Kernel Patch Protection (KPP), and achieve persistent, privileged code execution in the Secure World.

### Summary

In short, the "Broken Trust" exploit chain was:

1.  **Hijack Control Flow:** Use a buffer overflow in the **`keymaster` Trustlet** to overwrite a **C++ object's vtable pointer**, gaining code execution within that Trustlet.
2.  **Escalate Privileges:** From within the compromised Trustlet, invoke the vulnerable **logging SMC handler (`SMC #0x12`)** with the physical address of the TEE kernel's page tables to gain write access to them, leading to a full compromise of the Secure World.

---
